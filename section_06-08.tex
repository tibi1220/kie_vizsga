\documentclass[main.tex]{subfiles}

\begin{document}
  % ----------------------------------------------------------------------------
  % ------------------------------ Section 06 ----------------------------------
  % ----------------------------------------------------------------------------
  \section{Tétel – A számítástudomány alapjai} %6

  \fogalom{Turing gép}
  \begin{itemize}
    \item külső adat és tárolóterület:
    végtelen szalag, amelynek egymás után cellái vannak,
    amelyek vagy üresek, vagy jelöltek

    \item a gép egyszerre egy cellával foglalkozik
    (Az író/olvasó feje egy cellán áll)

    \item a szalagon tud jobbra-balra lépni,
    tud jelet olvasni, törölni és írni

    \item a bevitel, a számítás és a kivitel minden
    konkrét esetben véges marad, ezen túl a szalag üres

    \item a gép belső állapotait számozzuk
    
    \item a gép működését megadja egy explicit helyettesítési táblázat
    
    \item ha egy \zkod{algoritmus} elég
    \zkod{mechanikus} és \zkod{világos},
    akkor található olyan Turing-gép, amely azt végrehajtja

    \item a Turing gép definiálja mindazt,
    amit matematikailag \zkod{algoritmikus eljárás} alatt értünk

    \item minden más algoritmikus eljárást végrehajtó rendszer
    \zkod{ekvivalens} valamelyik Turing-géppel

    \item \zkod{megállási probléma}
    – nem tudjuk, hogy egy adott programmal megáll-e

    \item \pkod{nincs} arra bizonyítási módszerünk,
    hogy egy eljárás biztosan algoritmus
  \end{itemize}

  \fogalom{Eljárások}
  Nem garantálható, hogy véges lépésben,
  tehát valaha is választ kapjunk kérdésünkre.


  \fogalom{Algoritmusok}
  A választ \zkod{véges számú lépés} után mindenképpen megkapjuk.
  Egy \zkod{véges utasítássorozat}, amely bármely input esetén
  véges lépésszám után megáll, eredményt ad.
  Maga a Turing gép matematikai leírása az algoritmus
  fogalmának formális definíciója.
  Minden probléma, amelyre eljárás,
  procedúra szerkeszthető, Turing-géppel megoldható.
  Az ember azokra és csakis azokra a kérdésekre tud választ adni,
  amelyekre a Turing-gép is képes.
  A tartalmazás kérdése algoritmikusan eldönthetetlen.
  \begin{itemize}
    \item \zkod{bejárás} – elemek keresése
    
    \item \zkod{keresés} - adott értéknek megfelelő elemek kiválasztása
    
    \item \zkod{beszúrás} - új adat beillesztése
    
    \item \zkod{törlés} - adatelem eltávolítása
    
    \item \zkod{rendezés} - elemeket logikai sorrendbe
    
    \item \zkod{összeválogatás} - különböző rendezett
    adathalmazokból új elemhalmaz kialakítása
  \end{itemize}


  % ----------------------------------------------------------------------------
  % ------------------------------ Section 07 ----------------------------------
  % ----------------------------------------------------------------------------
  \section{Tétel – Adatszerkezetek} %7
  \begin{itemize}
    \item egyszerű vagy összetett alapadatok
    rendszerének matematikai, logikai \zkod{modellje}

    \item \zkod{elég jó} ahhoz, hogy tükrözze a valós kapcsolatokat
    
    \item \zkod{elég egyszerű} a kezeléshez
  \end{itemize}

  \fogalom{Tömbök}
  \begin{itemize}
    \item lineáris, egy vagy többdimenziós
    
    \item $n$ darab azonos típusú \zkod{adatelemből} áll
    
    \item az elemekre \zkod{indexhalmazzal} hivatkozunk
    
    \item az elemekhez bejárás nélkül férünk hozzá
  \end{itemize}

  \fogalom{Kapcsolt listák}
  \begin{itemize}
    \item a \zkod{kapcsolt lista} vagy \zkod{egyirányú lista}
    adatelemek, vagy csomópontok lineáris gyűjteménye,
    ahol az elemek sorrendjét rögzítjük
    \begin{itemize}
      \item a \zkod{mutatókat} tároló elemeket
      \zkod{kapcsolómezőnek hívjuk}
    \end{itemize}

    \item a \zkod{kétirányó listák} mindkét irányban bejárhatóak
    
    \item a \zkod{ciklikusan kapcsolt listák} nem rendelkeznek
    első és utolsó elemmel, hiszen az "első" az "utolsóra" mutat
  \end{itemize}

  \fogalom{Gráf}
  \begin{itemize}
    \item A \zkod{gráf} két halmazzal jellemezhető adatszerkezet
    \begin{itemize}
      \item a \zkod{csomópontok} sorszámozott halmazzal
      
      \item az elemeket összekötő számpárral jellemzett
      \zkod{élek halmaza}
    \end{itemize}

    \item az összekötött csomópontokat \zkod{szomszéd}oknak hívjuk
    
    \item $\deg(u)$ a csomópont \zkod{fok}a a befutó élek száma
    \begin{itemize}
      \item ha $\deg(u) = 0$, akkor a csomópont \zkod{izolált}
    \end{itemize}

    \item a $v_0$-ból $v_n$-be mutató élek halmazát
    \zkod{út}nak nevezzük – $P \left( v_0; v_1; \dots ;v_n \right)$
    \begin{itemize}
      \item az út \zkod{zárt}, ha $v_0 = v_n$
      \item az út \zkod{egyszerű}, ha minden pontja különbözik
      \item az út \zkod{kör}, ha legalább 3 hosszú, egyszerű
    \end{itemize}

    \item egy $G$ gráf \zkod{összefüggő},
    ha bármely 2 pontja között létezik egyszerű út

    \item egy $G$ gráf \zkod{teljes},
    ha minden csomópontja minden csomópontjával össze van kötve.

    \item egy $G$ gráf \zkod{címkézett},
    ha éleihez adatokat rendelünk
    \begin{itemize}
      \item egy $G$ gráf \zkod{súlyozott},
      ha éleihez rendelt adatok nemnegatívak
    \end{itemize}

    \item egy $G$ gráf \zkod{irányított},
    ha az éleknek irányítottságuk van

    \item rendelhetünk hozzájuk mátrixokat:
    \begin{itemize}
      \item \zkod{szomszédsági mátrix} – $a_{ij} = 1$,
      ha $i$-ből $j$ felé halad él 
      
      \item \zkod{útmátrix} – $a_{ij} = 1$,
      ha $i$-ből $j$-be halad valamilyen út 
    \end{itemize}
  \end{itemize}  

  \fogalom{Fa}
  \begin{itemize}
    \item a \zkod{fa} köröket nem tartalmazó összefüggő gráf
    
    \item a \zkod{bináris fa} elemek véges halmaza, mely:
    \begin{itemize}
      \item vagy üres
      
      \item vagy egyetlen $\mathbf{T}$ elemhez (\zkod{gyökér})
      kapcsolt két diszjunkt $\mathbf{T1}$ és $\mathbf{T2}$
      részfa alkotja (\zkod{szukcesszor})

      \item a \zkod{zárócsomópont}nak nincsen szukcesszora
      (\zkod{levél}), az utolsó élet \zkod{ág}nak nevezzük
      
      \item egy \zkod{generáció}ba az azonos
      \zkod{szintszámú} elemek tartoznak
      (gyökér szintszáma 0)
      
      \item a \zkod{mélység} az azonos ágon elhelyezkedő
      elemek maximális száma
      
      \item \zkod{teljes}, ha az utolsó szintet kivéve
      a csomópontok száma maximális

      \item ábrázolhatóak:
      \begin{itemize}
        \item[$\circ$] kapcsolt szerkezettel
        \item[$\circ$] tömbökkel
        \item[$\circ$] szekvenciálisan ($2k$ helyek eltolva)
      \end{itemize}

      \item bejárás történhet pl. irányítás szerint
    \end{itemize}

    \item \zkod{általános fa} esetén
    nem csak 2 szukcesszor engedélyezett
    \begin{itemize}
      \item elemek véges halmata ($\mathbf{T}$), amely \dots
      \begin{itemize}
        \item[$\circ$] tartalmaz egy kitüntetett
        $\mathbf{R}$ gyökérelemet
        \item[$\circ$] a többi elem nem nulla diszjunkt
        részfája $\mathbf{T}$-nek
      \end{itemize}
    \end{itemize}
    
    \item \zkod{minimális feszítőfa probléma}
    (minimum spanning tree)
    \begin{itemize}
      \item minden csúcsot érintő, összefüggő,
      körmentes élhalmaz

      \item \fkod{bemenet:} összefüggő, súlyozott,
      irányítatlan $G = (V; E)$ gráf, ahol $k(u; v)$
      a súly, az $(u;v)$ az élköltséget fejezi ki

      \item \fkod{kimenet:} egy $\mathbf{F}$ feszítőfa,
      melyre az élköltség minimális:
      $k(\mathbf{F}) = \displaystyle\sum_{(u;v) \in \mathbf{F}} k(u;v)$
      
      \item megoldás \zkod{Kruskal algoritmus}sal, amely Egy
      \zkod{mohó} algoritmus
      \begin{itemize}
        \item[$\circ$] minden pillanatban a leghatékonyabb megoldást válassza ki
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \fogalom{Verem}
  \begin{itemize}
    \item a \zkod{verem} (\kkod{stack}) \textit{LIFO}
    típusú tároló.

    \item \kkod{push} és \kkod{pop} függvényekkel rendelkezik
  \end{itemize}

  \fogalom{Sor}
  \begin{itemize}
    \item a \zkod{sor} (\zkod{queue}) \textit{FIFO}
    típusú tároló.

    \item \kkod{push} és \kkod{pop} függvényekkel rendelkezik
  \end{itemize}


  % ----------------------------------------------------------------------------
  % ------------------------------ Section 08 ----------------------------------
  % ----------------------------------------------------------------------------
  \section{Tétel – Algoritmusok} %8

  \fogalom{Bejárás}
  \begin{itemize}
    \item Tömb bejárása \kkod{for} ciklussal lehetséges.
  \end{itemize}

  \fogalom{Keresés}
  \begin{itemize}
    \item a \zkod{szekvenciális keresés} bonyolultsága: $O(n)$
    \begin{itemize}
      \item sima \kkod{for} ciklusos keresés
    \end{itemize}

    \item a \zkod{bináris keresés} bonyolultsága: $\log_2(n)$
    \begin{itemize}
      \item rendezett minta felezéses keresése
    \end{itemize}
  \end{itemize}

  \fogalom{Rendezés}
  \begin{itemize}
    \item a \zkod{buborék rendezés} bonyolultsága: $O(n^2)$
    \begin{itemize}
      \item dupla \kkod{for} ciklusos rendezés $\binom{n}{2}$
    \end{itemize}

    \item a \zkod{quick sort} bonyolultsága: $n \cdot \log_2(n)$
    \begin{itemize}
      \item felezgetős keresés \kkod{for} ciklussal
    \end{itemize}
  \end{itemize}

  \fogalom{Algoritmusok bonyolultsága}
  \begin{itemize}
    \item $P$ a \zkod{polinomidőben megoldható} problémákat reprezentálja
    \begin{itemize}
      \item a gyakorlatban hatékonyan megoldható problémák osztálya
    \end{itemize}

    \item $NP$ a \zkod{polinomidőben verifikálható} problémák osztálya
    \begin{itemize}
      \item a lehetséges megoldások polinomidőben előállíthatók
      nemdeterminisztikus Turing-géppel,
      majd determinisztikusan polinomidőben ellenőrizhető az,
      hogy az előállított lehetséges megoldás valóban megoldás-e
    \end{itemize}

    \item megoldatlan probléma: $N \overset{?}{=} NP$
    
    \item \zkod{utazó ügynök probléma}
    \begin{itemize}
      \item célja a legkisebb költségű út megtalálása városok között,
      minden várost pontosan egyszer érintve és visszatérve a
      kiindulási pontba

      \item a városok közötti költség az Euklideszi távolságon alapul,
      a probléma szimmetrikus, a költségek konstansok
    \end{itemize}

    \item $B(n)$ – \zkod{bonyolultság}
  \end{itemize}

  \fogalom{Rekurzió}
  \begin{itemize}
    \item rekurzió esetén a függvényben, általában
    a visszatérésénél meghívjuk saját magát.

    \item rekurzivan megoldható problémák:
    \begin{itemize}
      \item a faktoriális
      \begin{lstlisting}
        int factorial(int n){
          if(n == 0) return 1;
          return n * factorial(n-1);
        }
      \end{lstlisting}

      \item az aranymetszés
      \begin{lstlisting}
        int golden_ratio(int n){
          if(n == 1 || n == 2) return 1;
          return golden_ratio(n-1) + golden_ratio(n-2)
        }
      \end{lstlisting}

      \item Hanoi tornyai
      \begin{lstlisting}
        void hanoi(int n, char from, char to, char tmp){
          if(n == 1){
            cout << "\nTedd at az 1. lemezt a(z) "
                << from << "rudrol a(z)" << to << " rudra.";
          }
          hanoi(n-1, from, tmp, to);
          cout << "\nTedd at a(z) " << n << " lemezt a(z) "
              << from << "rudrol a(z)" << to << " rudra.";
          hanoi(n-1, tmp, to, from);
        }
      \end{lstlisting}
    \end{itemize}
  \end{itemize}

\end{document}